#+STARTUP: overview

* Introduction
This is my =.emacsd= folder to load my preferred Emacs configuration. Although it "should" work out of the box, I've added some extra steps I've needed in the past to the section [[*Misc requirements][Misc requirements]].

* Contents                                                            :TOC_2:
- [[#introduction][Introduction]]
- [[#initialisation][Initialisation]]
  - [[#lexical-scoping][Lexical scoping]]
  - [[#minimal-emacs][Minimal-Emacs]]
  - [[#use-package][use-package]]
  - [[#auto-save][auto-save]]
  - [[#shell-environment][Shell environment]]
  - [[#misc-requirements][Misc requirements]]
- [[#custom-changes][Custom changes]]
  - [[#my-defaults][My defaults]]
  - [[#duplicate-line][Duplicate line]]
  - [[#makefile-commands][Makefile Commands]]
  - [[#kill-buff][Kill buff]]
  - [[#comment-line][Comment line]]
  - [[#focus-on-new-split-window][Focus on new split window]]
- [[#ui][UI]]
  - [[#theme][Theme]]
  - [[#modeline][Modeline]]
  - [[#dashboard][Dashboard]]
- [[#general-packages][General packages]]
  - [[#from-mimimal-emacs][From mimimal emacs]]
  - [[#try][Try]]
  - [[#helpful][Helpful]]
- [[#minibuffer-packages][Minibuffer packages]]
  - [[#vertico][Vertico]]
  - [[#orderless][Orderless]]
  - [[#marginalia][Marginalia]]
  - [[#consult][Consult]]
  - [[#embark][Embark]]
  - [[#which-key][which key]]
- [[#buffer-packages][Buffer packages]]
  - [[#ibuffer][ibuffer]]
  - [[#treemacs][Treemacs]]
  - [[#ace-window][ace window]]
  - [[#avy][Avy]]
  - [[#ultra-scroll][ultra-scroll]]
- [[#editing-packages][Editing packages]]
  - [[#drag-stuff][drag-stuff]]
  - [[#yasnippet][YASnippet]]
  - [[#iedit][iedit]]
  - [[#undo-tree][undo-tree]]
  - [[#multiple-cursors][multiple-cursors]]
  - [[#expand-region][expand-region]]
- [[#programming-packages][Programming packages]]
  - [[#git][Git]]
  - [[#lsp][LSP]]
  - [[#flycheck][flycheck]]
  - [[#dap-mode][dap-mode]]
  - [[#tree-sitter][Tree-sitter]]
  - [[#company-mode][company-mode]]
  - [[#parenthesis][Parenthesis]]
  - [[#indentation][Indentation]]
  - [[#languages][Languages]]
- [[#writing-packages][Writing packages]]
  - [[#defaults][Defaults]]
  - [[#flyspell][Flyspell]]
  - [[#ispell][Ispell]]
  - [[#languagetools][LanguageTools]]
  - [[#writegood-mode][writegood-mode]]
  - [[#latex][LaTeX]]
- [[#org-mode][Org-mode]]
  - [[#my-defaults-1][My defaults]]
  - [[#agenda][Agenda]]
  - [[#roam][Roam]]
  - [[#packages][Packages]]
- [[#hydra][Hydra]]
  - [[#git-sync][Git sync]]

* Initialisation
This section contains the basic commands to initialize your GNU Emacs with some of my default preferences.

** Lexical scoping
In Emacs 30, a warning has been introduced when a file is loaded without a lexical binding directive, either =t= or =nil=. This warning is part of the ongoing transition towards making lexical binding the default in future versions of Emacs. To avoid this warning, you can add the following line at the top of your Emacs Lisp files:

#+begin_src emacs-lisp
  ;; -*- lexical-binding: t; -*-
#+end_src

This cookie tells Emacs to use lexical scoping for variables which is now the default and recommended style for almost all modern Emacs Lisp code. Without it, older dynamic scoping is used, which can cause weird bugs or performance issues in some cases. I also had to add this to some files that caused a warning on startup (not required but I found it annoying)

** Minimal-Emacs
The [[https://github.com/KaiRJ/minimal-emacs.d?tab=readme-ov-file#customizations-packages-post-initel][minimal-emacs.d]] project is a lightweight and optimized Emacs base (init.el and early-init.el) that gives you full control over your configuration (without the complexity of, for instance, Doom Emacs or Spacemacs). It provides better defaults, an optimized startup, and a clean foundation for building your own vanilla Emacs setup. See the linked page for more details of the defaults set.
** use-package
=use-package= is automatically set up by =minimal-emacs=, but to save some typing I'm also turning on always using =ensure t=:

#+begin_src emacs-lisp
  (setq use-package-always-ensure t)
#+end_src

If you are having trouble when starting Emacs, you can pass Emacs the =--debug-init= command line flag. To get even more information when using that flag I've added these options:

#+begin_src emacs-lisp
  (when init-file-debug
    (setq use-package-verbose t
          use-package-expand-minimally nil
          use-package-compute-statistics t))
#+end_src

** auto-save
Enabling auto-save-mode mitigates the risk of data loss in the event of a crash. Auto-saved data can be recovered using the =recover-file= or =recover-session= functions:

#+begin_src emacs-lisp
  (setq auto-save-default t)
  (setq auto-save-interval 300)
  (setq auto-save-timeout 30)
  (setq auto-save-file-name-transforms `((".*" "~/.emacs.d/var/autosave/" t)))
#+end_src

When auto-save-visited-mode is enabled, Emacs will auto-save file-visiting buffers after a certain amount of idle time if the user forgets to save it with =save-buffer= or =C-x s= for example.

#+begin_src emacs-lisp
  (setq auto-save-visited-interval 30) ;; Save after 30 seconds if inactivity
  (auto-save-visited-mode 1)
#+end_src

** Shell environment
I'm using the [[https://github.com/purcell/exec-path-from-shell][exec-path-from-shell]] package so that my terminal and Emacs enviroments are the same:

#+begin_src emacs-lisp
  (use-package exec-path-from-shell
    :commands (shell eshell)
    :config
    (exec-path-from-shell-initialize))
#+end_src

** Misc requirements
These are instructions you may need for a fresh install of Emacs using this init file:

- Running Emacs from pop shop caused errors with the environment being completely different, I fixed this by downloading directly from [[https://www.gnu.org/software/emacs/][Emacs]].

- For the [[https://github.com/seagle0128/doom-modeline][doom-modeline]] run =M-x nerd-icons-install-fonts= to install the necessary fonts.

- Might need to also run =M-x all-the-icons-install-fonts=,
#+begin_src emacs-lisp
  (use-package all-the-icons)
#+end_src

- For =lsp-mode= you will need to install all the language servers, eg. =sudo apt install clangd=. But emacs should prompt you to install them automatically anyway as you open files, if you run into issues just install them from the terminal.
  - On linux, I ran into an error of Emacs not being able to find =npm= to install for example the =bash-ls=.
  - I therefore had to install =nvm= in my terminal, following the instructions [[https://github.com/nvm-sh/nvm?tab=readme-ov-file#installing-and-updating][here]] (=apt= installs old versions that didn't work either).
  - For lsp-itex, the automatic install wasn't working but just try M-x lsp-install-server ltex-ls instead. Or if you download directly note to place the executable in =~/.emacs.d/.cache/lsp/ltex-ls/latest=.

- For =dap-mode= a one-time step is required to download the extension and set it up automatically  =M-x dap-cpptools-setup= then you are good start debugging.

* Custom changes
This section contains my elisp code and some small keybinding changes that I use frequently in my workflow. Note, I change package specific keybindings when I install that package.

** My defaults
On top of the [[https://github.com/KaiRJ/minimal-emacs.d?tab=readme-ov-file#customizations-packages-post-initel][minimal-emacs.d]] defaults these are some additional values I use:

#+begin_src emacs-lisp
  (use-package emacs
    :ensure nil

    :hook
    ((before-save-hook . whitespace-cleanup) ;; Clean up white space when file is saved
     (prog-mode . display-line-numbers-mode) ;; Add line numbers to progam modes
     (prog-mode . display-fill-column-indicator-mode) ;; Add column fill indicator
     (prog-mode . (lambda () (setq truncate-lines t)))) ;; Line Wrappings

    :bind
    (("M-r" . quary-repace)
     ("C-;" . comment-line) ;; Bind comment-line to C-; instead of C-x C-;
     ("M-n" . scroll-up-line) ;; So I can scroll with one chord easily
     ("M-p" . scroll-down-line)
     ("C-z" . nil) ;; Don't like this suspend window keybinding
     ([remap kill-buffer] . kill-this-buffer)) ;; Don't ask before killing a buffer.

    :custom
    ((select-enable-clipboard t "Merge system's and Emacs' clipboard")
     (save-interprogram-paste-before-kill t "Save system clipboard before replacing")
     (next-line-add-newlines t "C-n adds new line if reaches end of buffer")
     (delete-selection-mode 1 "Delete highlighted text by typing")
     (inhibit-compacting-font-caches t "Don't compact font caches during GC")
     (global-subword-mode 1 "Treat CamelCase as distinct words")
     (package-install-upgrade-built-in t "Allow Emacs to upgrade built-in packages"))

    :custom-face
    (default ((t (:height 130))))) ;; Font size
#+end_src

** Duplicate line
Duplicates the current line below.

#+begin_src emacs-lisp
  (use-package duplicate-line
    :ensure nil
    :bind ("s-d" . my/duplicate-line)
    :preface
    (defun my/duplicate-line()
      "Duplicate the current line below."
      (interactive)
      (move-beginning-of-line 1)
      (kill-line)
      (yank)
      (open-line 1)
      (next-line 1)
      (yank)))
#+end_src

** TODO Makefile Commands
Check if there's a package to work with make projects. Also add these to use-package like others

Key bindings to quickly make and clean makefile projects.

#+begin_src emacs-lisp
  (defun kai/compile-build ()
    "Compile using 'make build'."
    (interactive)
    (compile "make build"))

  (defun kai/compile-clean ()
    "Clean using 'make clean'."
    (interactive)
    (compile "make clean"))

  ;; makefile keybindings
  (keymap-global-set "<f5>" 'kai/compile-build)
  (keymap-global-set "<f6>" 'kai/compile-clean)
#+end_src
** Kill buff
Kill the current buffer instead of having to pick it.

#+begin_src emacs-lisp
  (use-package kill-this-buffer
    :ensure nil
    :bind ("C-x k" . my/kill-this-buffer)
    :preface
    (defun my/kill-this-buffer ()
      "Kill the current buffer."
      (interactive)
      (kill-buffer (current-buffer))))
#+end_src
** Comment line
I prefer the point to stay in place when I comment a line.

#+begin_src emacs-lisp
  (use-package comment-line-stay
    :ensure nil
    :bind ("C-;" . my/comment-line-stay)
    :preface
    (defun my/comment-line-stay ()
      "Toggle comment on current line without moving point."
      (interactive)
      (save-excursion
        (comment-line nil))))  ;; nil = behave normally (toggle)
#+end_src

** Focus on new split window
Most of the time, I want to split a window and put the focus on it to perform an action. By default GNU Emacs does not give the focus to this new window, the functions change that behaviour.

#+begin_src emacs-lisp
(use-package split-last-buffer
  :ensure nil
  :bind (("C-x 2" . my/vsplit-last-buffer)
         ("C-x 3" . my/hsplit-last-buffer))
  :preface
  (defun my/hsplit-last-buffer ()
    "Focus to the last created horizontal window."
    (interactive)
    (split-window-horizontally)
    (other-window 1))

  (defun my/vsplit-last-buffer ()
    "Focus to the last created vertical window."
    (interactive)
    (split-window-vertically)
    (other-window 1)))
#+end_src

* UI
Most the small UI changes are made by [[https://github.com/KaiRJ/minimal-emacs.d?tab=readme-ov-file#customizations-packages-post-initel][minimal-emacs.d]], here I am just adding a new theme and adjusting the modeline.

** Theme
I'm using the [[https://github.com/doomemacs/themes][doom-one]] theme:

#+begin_src emacs-lisp
  (use-package doom-themes
    :config
    (load-theme 'doom-one t)
    (doom-themes-visual-bell-config) ;; Enable flashing mode-line on errors
    (doom-themes-org-config))        ;; Corrects (and improves) org-mode's native fontification.
#+end_src

** Modeline
And the [[https://github.com/seagle0128/doom-modeline][doom-modeline]]:

#+begin_src emacs-lisp
  (use-package doom-modeline
    :hook
    (after-init . doom-modeline-mode)
    :custom
    (doom-modeline-icon (display-graphic-p))
    (doom-modeline-mu4e nil)
    (doom-modeline-buffer-modification-icon nil)
    (doom-modeline-buffer-file-name-style 'file-name-with-project)
    (doom-modeline-position-column-line-format '("L%l"))
    (doom-modeline-checker-simple-format nil)
    (doom-modeline-buffer-encoding nil)
    (doom-modeline-vcs-max-length 12))
#+end_src

** Dashboard
This package gives a nicer startup menu using the [[https://github.com/emacs-dashboard/emacs-dashboard][dashboard]] package.

#+begin_src emacs-lisp
  ;; optional dependancy of emacs-dashboard
  (use-package page-break-lines)

  (use-package dashboard
    :config
    (dashboard-setup-startup-hook)
    :custom
    (dashboard-items '((projects . 5)
                       (recents . 5)))
    (dashboard-set-file-icons t)
    (dashboard-set-heading-icons t)
    (dashboard-set-navigator t)
    (dashboard-startup-banner 'official))
#+end_src

* General packages
These are the packages that aren't really tied to a specific mode, and more general to all of Emacs.

** From mimimal emacs
The =recentf=, =savehist=, =saveplace=, and =auto-revert= built-in packages are already configured by [[https://github.com/KaiRJ/minimal-emacs.d?tab=readme-ov-file#customizations-packages-post-initel][minimal-emacs.d]]. They just need to be activated (depending on which you want).

=savehist= is an Emacs feature that preserves the minibuffer history between sessions. It saves the history of inputs in the minibuffer, such as commands, search strings, and other prompts, to a file. This retains their minibuffer history across Emacs restarts.

#+begin_src emacs-lisp
    (use-package savehist
      :ensure nil
      :commands (savehist-mode savehist-save)
      :hook
      (after-init . savehist-mode)
      :custom
      (savehist-autosave-interval 600)
      (savehist-additional-variables
       '(kill-ring                        ; clipboard
         register-alist                   ; macros
         mark-ring global-mark-ring       ; marks
         search-ring regexp-search-ring)))
  #+end_src

  =save-place-mode= enables Emacs to remember the last location within a file upon reopening.

  #+begin_src emacs-lisp
  (use-package saveplace
    :ensure nil
    :commands (save-place-mode save-place-local-mode)
    :hook
    (after-init . save-place-mode)
    :custom
    (save-place-limit 400))
#+end_src

** Try
The [[https://github.com/larstvei/Try][Try]] package lets you try different packages without having to install them.

#+begin_src emacs-lisp
  (use-package try
    :commands try)
#+end_src

** Helpful
To have a more user-friendly documentation I use the [[https://github.com/Wilfred/helpful][helpful]] package.

#+begin_src emacs-lisp
  (use-package helpful
    :commands (helpful-function
               helpful-macro)
    :bind
    ("C-h f" . helpful-callable)
    ("C-h v" . helpful-variable)
    ("C-h k" . helpful-key)
    ("C-h x" . helpful-command)
    ("C-h ." . helpful-at-point)
    ("C-h o" . helpful-symbol))
#+end_src

* Minibuffer packages
These packages make everything in the minibuffer nicer and easier.

** Vertico
[[https://github.com/minad/vertico][Vertico]] provides a vertical completion interface, making it easier to navigate and select from completion candidates (e.g., when =M-x= is pressed). It is recommended to also enable the =savehist= package, which I have done.

#+begin_src emacs-lisp
  (use-package vertico
    :config
    (vertico-mode))
#+end_src

** Orderless
Vertico leverages [[https://github.com/oantolin/orderless][Orderless]]' flexible matching capabilities, allowing the input of multiple patterns separated by spaces.

#+begin_src emacs-lisp
  (use-package orderless
    :custom
    (completion-styles '(orderless basic))
    (completion-category-defaults nil)
    (completion-category-overrides '((file (styles partial-completion))))
    (completion-pcm-leading-wildcard t))
#+end_src

** Marginalia
[[https://github.com/minad/marginalia][Marginalia]] allows Embark to offer you preconfigured actions in more contexts. In addition to that, Marginalia also enhances Vertico by adding rich annotations to the completion candidates displayed in Vertico's interface.

#+begin_src emacs-lisp
  (use-package marginalia
    :commands (marginalia-mode marginalia-cycle)
    :hook (after-init . marginalia-mode))
#+end_src

** TODO Consult
TODO should learn to use this more, and shorted the config to what i use and need

[[https://github.com/minad/consult][Consult]] offers a suite of commands for efficient searching, previewing, and interacting with buffers, file contents, and more, improving various tasks.

#+begin_src emacs-lisp
  (use-package consult
    :bind
    (;; C-c bindings in `mode-specific-map'
     ("C-c M-x" . consult-mode-command)
     ("C-c h" . consult-history)
     ("C-c k" . consult-kmacro)
     ("C-c m" . consult-man)
     ("C-c i" . consult-info)
     ([remap Info-search] . consult-info)
     ;; C-x bindings in `ctl-x-map'
     ("C-x M-:" . consult-complex-command)
     ("C-x b" . consult-buffer)
     ("C-x 4 b" . consult-buffer-other-window)
     ("C-x 5 b" . consult-buffer-other-frame)
     ("C-x t b" . consult-buffer-other-tab)
     ("C-x r b" . consult-bookmark)
     ("C-x p b" . consult-project-buffer)
     ;; Custom M-# bindings for fast register access
     ("M-#" . consult-register-load)
     ("M-'" . consult-register-store)
     ("C-M-#" . consult-register)
     ;; Other custom bindings
     ("M-y" . consult-yank-pop)
     ;; M-g bindings in `goto-map'
     ("M-g e" . consult-compile-error)
     ("M-g f" . consult-flymake)
     ("M-g g" . consult-goto-line)
     ("M-g o" . consult-outline)
     ("M-g m" . consult-mark)
     ("M-g k" . consult-global-mark)
     ("M-g i" . consult-imenu)
     ("M-g I" . consult-imenu-multi)
     ;; M-s bindings in `search-map'
     ("M-s d" . consult-find)
     ("M-s c" . consult-locate)
     ("M-s g" . consult-grep)
     ("M-s G" . consult-git-grep)
     ("M-s r" . consult-ripgrep)
     ("M-s l" . consult-line)
     ("M-s L" . consult-line-multi)
     ("M-s k" . consult-keep-lines)
     ("M-s u" . consult-focus-lines)
     ;; Isearch integration
     ("M-s e" . consult-isearch-history)
     :map isearch-mode-map
     ("M-e" . consult-isearch-history)
     ("M-s e" . consult-isearch-history)
     ("M-s l" . consult-line)
     ("M-s L" . consult-line-multi)
     ;; Minibuffer history
     :map minibuffer-local-map
     ("M-s" . consult-history)
     ("M-r" . consult-history))

    ;; Enable automatic preview at point in the *Completions* buffer.
    :hook (completion-list-mode . consult-preview-at-point-mode)

    :init
    ;; Optionally configure the register formatting. This improves the register
    (setq register-preview-delay 0.5
          register-preview-function #'consult-register-format)

    ;; Optionally tweak the register preview window.
    (advice-add #'register-preview :override #'consult-register-window)

    ;; Use Consult to select xref locations with preview
    (setq xref-show-xrefs-function #'consult-xref
          xref-show-definitions-function #'consult-xref)

    ;; Aggressive asynchronous that yield instantaneous results. (suitable for
    ;; high-performance systems.) Note: Minad, the author of Consult, does not
    ;; recommend aggressive values.
    ;; Read: https://github.com/minad/consult/discussions/951
    ;;
    ;; However, the author of minimal-emacs.d uses these parameters to achieve
    ;; immediate feedback from Consult.
    ;; (setq consult-async-input-debounce 0.02
    ;;       consult-async-input-throttle 0.05
    ;;       consult-async-refresh-delay 0.02)

    :config
    (consult-customize
     consult-theme :preview-key '(:debounce 0.2 any)
     consult-ripgrep consult-git-grep consult-grep
     consult-bookmark consult-recent-file consult-xref
     consult--source-bookmark consult--source-file-register
     consult--source-recent-file consult--source-project-recent-file
     ;; :preview-key "M-."
     :preview-key '(:debounce 0.4 any))
    (setq consult-narrow-key "<"))
#+end_src

** TODO Embark
TODO should learn to learn this, see minimal-emacs for a larger config

The [[https://github.com/oantolin/embark][Embark]] package acts like a context menu (or right-click) to perform context-sensitive actions on selected items directly from the completion interface.

#+begin_src emacs-lisp
  (use-package embark
    :bind
    (("C-." . embark-act)
     ("C-h B" . embark-bindings))) ;; alternative for `describe-bindings'

  (use-package embark-consult
    :hook
    (embark-collect-mode . consult-preview-at-point-mode))
#+end_src

** which key
Display possible key bindings following incomplete command.

#+begin_src emacs-lisp
  (use-package which-key
    :ensure nil ; builtin
    :commands which-key-mode
    :hook (after-init . which-key-mode)
    :custom
    (which-key-idle-delay 0.5)
    (which-key-idle-secondary-delay 0.25)
    (which-key-add-column-padding 1)
    (which-key-max-description-length 40))
#+end_src

* Buffer packages
This section contains some packages that make navigating between and around buffers and files easier.

** ibuffer
The =ibuffer= built-in package provides better buffer management over =buffer-menu=, with a nicer visual interface and syntax colour. To organise the =ibuffer= menu, I use either the [[https://github.com/purcell/ibuffer-v][ibuffer-vc]] or the [[https://github.com/muffinmad/emacs-ibuffer-project/blob/master/README.md][ibuffer-project]] package to sort the buffers by git repository or  project, respectively. To set which is in use, just =:disbaled= the one you don't want.

#+begin_src emacs-lisp
  (use-package ibuffer
    :ensure nil
    :bind ("C-x C-b" . ibuffer)
    :hook (ibuffer . my/ibuffer-apply-filter-groups)
    :custom
    ;; (setq ibuffer-default-sorting-mode 'major-mode)
    (ibuffer-show-empty-filter-groups nil))

  (use-package ibuffer-vc
    :disabled
    :after ibuffer
    :config
    (setq ibuffer-generate-new-filter-groups_fn 'ibuffer-vc-generate-filter-groups-by-vc-root))

  (use-package ibuffer-project
    :after ibuffer
    :config
    (setq ibuffer-generate-new-filter-groups_fn 'ibuffer-project-generate-filter-groups))

  (defun my/ibuffer-apply-filter-groups ()
    "Combine the current ibuffer filter groups with those in ibuffer-active-filter-group.
    ibuffer-generate-new-filter-groups_fn is set in both the ibuffer-vc and ibuffer-project use-package config, and chosen by =:disabled= the ones you don't want to use. Function adapted from `https://github.com/reinh/dotemacs/blob/master/conf/init.org#ido'."
    (let ((ibuf (get-buffer "*Ibuffer*")))
      (when (and ibuf (boundp 'ibuffer-generate-new-filter-groups_fn))
        (setq ibuffer-filter-groups
              (append
               (funcall ibuffer-generate-new-filter-groups_fn)
               ibuffer-saved-filter-groups))
        (with-current-buffer ibuf
          (pop-to-buffer ibuf)
          (ibuffer-update nil t)))))
#+end_src

** TODO Treemacs
I am disabling this for now as I never use it. Will need to edit all the code to use the best practices from use-package.

#+begin_src emacs-lisp
  (use-package treemacs
    :disabled
    :config
    (progn
      (setq treemacs-hide-dot-git-directory          t
            treemacs-move-files-by-mouse-dragging    t
            treemacs-sorting                         'alphabetic-asc
            treemacs-width                           28)
      (treemacs-project-follow-mode t)
      (treemacs-resize-icons 24))
    :bind
    (:map global-map
          ("M-0"       . treemacs-select-window)
          ("C-x t 1"   . treemacs-delete-other-windows)
          ("C-x t d"   . treemacs-select-directory)
          ("C-x t t"   . treemacs)
          ("C-x t B"   . treemacs-bookmark)
          ("C-x t C-t" . treemacs-find-file)
          ("C-x t M-t" . treemacs-find-tag)))

  (use-package treemacs-magit
    :disabled
    :after treemacs)

  (use-package treemacs-all-the-icons
    :disabled
    :after treemacs all-the-icons
    :config (treemacs-load-theme "all-the-icons"))
#+end_src

** ace window
The [[https://github.com/abo-abo/ace-window][ace-window]] package makes switching between multiple windows much easier. I've also changed the keys used to select a window to the home row keys.

#+begin_src emacs-lisp
  (use-package ace-window
    :bind
    ("M-o" . ace-window)
    :custom
    (aw-keys '(?a ?s ?d ?f ?g ?h ?j ?k ?l))
    :custom-face
    (aw-leading-char-face
     ((t (:inherit ace-jump-face-foreground :height 3.0 :foreground ,(doom-color 'blue))))))
#+end_src

** Avy
[[https://github.com/abo-abo/avy][Avy]] is a very small package that provides some commands for quickly navigating around the current view in the buffer.

#+begin_src emacs-lisp
  (use-package avy
    :bind
    ("M-s c" . avy-goto-word-1)
    ("M-g M-g" . 'avy-goto-line))
#+end_src
** ultra-scroll
[[https://github.com/jdtsmith/ultra-scroll][ultra-scroll]] is a simple package that provides smooth-scrolling.

#+begin_src emacs-lisp
  (use-package ultra-scroll
    :custom
    (scroll-conservatively 3)
    (scroll-margin 0)
    :config
    (ultra-scroll-mode 1))
#+end_src

* Editing packages
These packages are specifically used for editing text inside a buffer. There are used in all major modes.

** drag-stuff
It is useful to be able to move a line or a region up and down without having to =kill-region= (=C-w=) and =yank (C-y)=. The [[https://github.com/rejeep/drag-stuff.el][drag-stuff]] package allows you to moves the current work, line or if marked, the current region.

#+begin_src emacs-lisp
  (use-package drag-stuff
    :bind
    ("s-n" . drag-stuff-down)
    ("s-p" . drag-stuff-up)
    ("s-f" . drag-stuff-right)
    ("s-b" . drag-stuff-left)
    :custom
    (drag-stuff-global-mode 1))

#+end_src
** YASnippet
[[https://github.com/joaotavora/yasnippet][YASnippet]] is a template system for Emacs. It allows you to type an abbreviation and automatically expand it into function templates. [[https://github.com/AndreaCrotti/yasnippet-snippets][YASnippet-snippets]] contains a large collection of snippets to use.

#+begin_src emacs-lisp
  (use-package yasnippet
    :config (yas-global-mode))

  (use-package yasnippet-snippets
    :after yasnippet
    :config
    (yasnippet-snippets-initialize))
#+end_src

** iedit
[[https://github.com/victorhge/iedit][iedit]] allows you to alter one occurrence of some text in a buffer (possibly narrowed) or region, and simultaneously have other occurrences changed in the same way, with visual feedback as you type. Once in iedit mode, you can select a region and hit =C-r= again to restrict the search area to the region.

#+begin_src emacs-lisp
  (use-package iedit
    :bind
    ("C-r" . iedit-mode))
#+end_src

** undo-tree
The [[https://gitlab.com/tsc25/undo-tree][undo-tree]] package visualises the undo history as a tree for easy navigation.

#+begin_src emacs-lisp
  (use-package undo-tree
    :init
    (global-undo-tree-mode)
    :config
    (setq undo-tree-visualizer-diff t) ;; show difs
    (setq undo-tree-auto-save-history t) ;; save history to file
    (setq undo-tree-visualizer-timestamps t) ;; show timestamps

    ;; Create the undo history directory if it doesn't exist
    (let ((undo-history-dir (expand-file-name "undo-history" user-emacs-directory)))
      (unless (file-directory-p undo-history-dir)
    (make-directory undo-history-dir)))

    ;; Set the directory for undo history files
    (setq undo-tree-history-directory-alist
      `((".*" . ,(expand-file-name "undo-history" user-emacs-directory)))))
#+end_src

** TODO multiple-cursors
TODO This package is pretty large, need to spend some time learning how to use it fully. Start with the git page and [[https://emacsrocks.com/e13.html][this]] video.

The [[https://github.com/magnars/multiple-cursors.el][multiple-cursors]] package adds the ability to add cursors all over the buffer to edit in lots of places at once.

#+begin_src emacs-lisp
  (use-package multiple-cursors
    :bind
    ("C->" . mc/mark-next-like-this)
    ("C-<" . mc/mark-previous-like-this))
    #+end_src

** expand-region
Expand the marked region in semantic increments (=C-- C-= to reduce region).

#+begin_src emacs-lisp
  (use-package expand-region
    :bind
    ("C-=" . er/expand-region))
#+end_src

* TODO Programming packages
This section contains all the packages I am using for programming. Including a dedicated section for specific [[*Languages][Languages]].

** Git
*** magit
[[https://magit.vc/][Magit]] makes working with git in Emacs, very very easy.

#+begin_src emacs-lisp
  (use-package magit
    :commands magit-status-mode)
#+end_src

*** git-gutter and git-gutter-fringe
[[https://github.com/emacsorphanage/git-gutter][git-gutter]] is a simple package that shows the git difs to the side of each line that there is a change. I'm also using the [[https://github.com/emacsorphanage/git-gutter-fringe][git-gutter-fringe]] package to make this look similar to VScode (as per [[https://ianyepan.github.io/posts/emacs-git-gutter/][this]] demo).

#+begin_src emacs-lisp
  (use-package git-gutter
    :custom ((global-git-gutter-mode 1 "Turn on for every mode")
             (git-gutter:update-interval 0.2 "If too small causes lagging")))

  (use-package git-gutter-fringe
    :after git-gutter
    :custom
    (global-git-gutter-mode 1 "Turn on for every mode")
    :custom-face
    (git-gutter-fr:modified ((t (:foreground "#2375B3"))))
    ;; (git-gutter-fr:added    ((t (:foreground "blue"))))
    ;; (git-gutter-fr:deleted  ((t (:foreground "white"))))
    :config
    (define-fringe-bitmap 'git-gutter-fr:added [224] nil nil '(center repeated))
    (define-fringe-bitmap 'git-gutter-fr:modified [224] nil nil '(center repeated))
    (define-fringe-bitmap 'git-gutter-fr:deleted [128 192 224 240] nil nil 'bottom))

#+end_src

** TODO LSP
TODO need to expand on all this and check them out - maybe switch to eglot, its built in and lighter

The main benefit of using Language Server Protocol (LSP) to configure the management of your programming languages is that LSP servers are also used by other text editors, increasing contributions to these packages.

*** lsp-mode

That's where [[https://github.com/emacs-lsp/lsp-mode][lsp-mode]] comes in!

I was running into problems with lsp-mode and C++, where it would should errors in C++20 but would compile and run fine. I think this was due to the clangd downloaded by lsp-mode being too old, so I've directly set it to be my local download using =lsp-clients-clangd-executable=.

#+begin_src emacs-lisp
  (use-package lsp-mode
    :commands
    (lsp lsp-deferred)
    :hook
    ((prog-mode . lsp-deferred)
     (lsp-mode . lsp-enable-which-key-integration))
    :custom
    (lsp-enable-folding nil)
    (lsp-enable-links nil)
    (lsp-enable-snippet nil)
    (lsp-keymap-prefix "C-c l")
    (lsp-prefer-capf t)                  ;; Use completion-at-point-functions
    (lsp-headerline-breadcrumb-enable t) ;; Show breadcrumbs
    (lsp-clangd-binary-path "/usr/bin/clangd-20"))

  ;; Clangd is fast
  (setq gc-cons-threshold (* 100 1024 1024)
        read-process-output-max (* 1024 1024)
        treemacs-space-between-root-nodes nil
        company-idle-delay 0.500
        company-minimum-prefix-length 1
        lsp-idle-delay 0.1)  ;; clangd is fast
#+end_src

*** TODO lsp-ui
TODO i think this is causing issues with pop os tiling

In addition to =lsp-mode=, it is possible to use =lsp-ui= to get additional information (e.g., documentation) when hovering a variable or a function.

#+begin_src emacs-lisp
  (use-package lsp-ui
    :hook (lsp-mode . lsp-ui-mode)
    :custom
    (lsp-ui-sideline-enable t)
    (lsp-ui-doc-enable nil)
    (lsp-ui-doc-position 'at-point))
#+end_src

*** TODO consult-lsp
TODO learn how to use this

When using =lsp=, it is likely that you will encounter programming errors. To navigate through these errors via the minibuffer, you can use a package for that. If like me, you use =consult= with your minibuffer completion, then =consult-lsp= is made for you.

#+begin_src emacs-lisp
  (use-package consult-lsp
    :disabled
    :commands (consult-lsp-diagnostics consult-lsp-symbols))
#+end_src

*** lsp-treemacs

For treemacs integrating with lsp-mode.

#+begin_src emacs-lisp
  (use-package lsp-treemacs
    :ensure t
    :after (lsp-mode treemacs)
    :bind
    ("C-c l l" . lsp-treemacs-errors-list) ; TODO move to hydra table
    :config
    (lsp-treemacs-sync-mode 1))
#+end_src
** flycheck
#+begin_src emacs-lisp
  (use-package flycheck
    :delight
    :hook (lsp-mode . flycheck-mode)
    :bind (:map flycheck-mode-map
                ("M-'" . flycheck-previous-error)
                ("M-\\" . flycheck-next-error))
    :custom (flycheck-display-errors-delay .3))
#+end_src
** dap-mode

[[https://github.com/emacs-lsp/dap-mode][dap-mode]] uses the Debug Adapter Protocol wire protocol for communication between client and Debug Server. You won't find a better debugger.

#+begin_src emacs-lisp
  (use-package dap-mode
    :after lsp-mode
    :hook (dap-stopped . (lambda (arg) (call-interactively #'dap-hydra)))
    :config
    (dap-auto-configure-mode)  ;; Automatically configures dap-mode
    (require 'dap-cpptools)

    (dap-register-debug-template
     "cpptools::main"
     (list :type "cppdbg"
           :request "launch"
           :MIMode "lldb"
           :program "${workspaceFolder}/build/main"
           :cwd "${workspaceFolder}"))

    (dap-register-debug-template
     "cpptools::main-input"
     (list :name "cpptools::main-input"
           :type "cppdbg"
           :request "launch"
           :MIMode "lldb"
           :program "${workspaceFolder}/build/main"
           :cwd "${workspaceFolder}"
           :externalConsole t)))
#+end_src
** TODO Tree-sitter

[[https://tree-sitter.github.io/tree-sitter/][Tree-sitter]] is a fast, incremental parsing library that gives Emacs (and other editors) rich, real-time syntax trees of your code. It lets your editor understand code like a compiler does - with actual structure, not just regex-y color rules. As of Emacs 29 it is built in.

I am currently using [[https://github.com/renzmann/treesit-auto][treesit-auto]] to make the setup easier.

Disabled for now as couldn't figure out how to use the correct C++ style.

#+begin_src emacs-lisp
  (use-package treesit-auto
    :disabled
    :custom
    (treesit-auto-install 'prompt)
    :config
    (treesit-auto-add-to-auto-mode-alist 'all)
    (global-treesit-auto-mode))
#+end_src

** TODO company-mode
TODO try corfu as company boxes messes with pop os auto tiling - see minimal emacs

Auto-completion with GNU Emacs is mainly combined with LSP mode. Therefore the development of any programming language is made easier with auto-completion, which involves a completion at point followed by the display of a small pop-in containing the candidates. I am using [[https://github.com/company-mode/company-mode][company-mode]] which is easier and smoother to configure.

#+begin_src emacs-lisp
  (use-package company
    :after lsp-mode
    :hook (prog-mode . company-mode)
    :custom
    (company-show-quick-access t)
    (company-idle-delay 0.2)              ;; Delay before suggestions popup
    (company-minimum-prefix-length 1)     ;; Show suggestions after 1 char
    (company-tooltip-align-annotations t) ;; Align annotations (e.g., function signatures)
    (company-preview-frontend t)          ;; show first completion candidate inline
    (company-show-doc-buffer nil))

  ;; For visuals
  ;; This doesnt work with pop os auto tilling
  (use-package company-box
    :disabled
    :after company
    :init (setq company-box-icons-alist 'company-box-icons-all-the-icons)
    :hook (company-mode . company-box-mode))
#+end_src
** Parenthesis
*** TODO rainbow-delimiters

TODO add link

Highlights delimiters according to their depth.

#+begin_src emacs-lisp
  (use-package rainbow-delimiters
    :hook
    (prog-mode . rainbow-delimiters-mode))
#+end_src

*** TODO smartparens
Need to learn how to use this. Might only be good to use strict mode with emacs files

#+begin_src emacs-lisp
  (use-package smartparens
    :disabled
    :ensure t
    :hook
    ( ;; (prog-mode . smartparens-strict-mode)
     (markdown-mode-hook . turn-on-smartparens-mode)) ;; can use strict-mode also
    :config
    ;; load default config
    (require 'smartparens-config)
    :bind
    ("C-M-a" . sp-beginning-of-sexp)
    ("C-M-e" . sp-end-of-sexp)
    ("C-<up>" . sp-up-sexp)
    ("C-<down>" . sp-down-sexp)
    ("M-<up>" . sp-backward-up-sexp)
    ("M-<down>" . sp-backward-down-sexp)
    ("M-[" . sp-backward-unwrap-sexp)
    ("M-]" . sp-unwrap-sexp))
#+end_src

** TODO Indentation
TODO maybe make a formatting section

My setup for dealing with indentation

*** aggressive-indent
#+begin_src emacs-lisp
  (use-package aggressive-indent
    :disabled
    :custom
    (aggressive-indent-comments-too t))
#+end_src

*** highlight-indentation-guides

Currently using [[https://github.com/DarthFennec/highlight-indent-guides][highlight-indentation-guides]] for my indentation highlight as its easy to use. Although I'd like to eventually find a solution to highlight blank spaces as well.

#+begin_src emacs-lisp
(use-package highlight-indent-guides
  :hook (prog-mode . highlight-indent-guides-mode)
  :config
  ;; Use thin character style
  (setq highlight-indent-guides-method 'character)
  (setq highlight-indent-guides-character ?|) ;; Unicode thin vertical bar
  (setq highlight-indent-guides-responsive 'top) ;; Active indent
  (setq highlight-indent-guides-auto-enabled t)

  ;; Show guides even on blank lines
  (setq highlight-indent-guides-show-leading-blank-lines t)

  ;; Customize colors to fit doom-one
  (set-face-foreground 'highlight-indent-guides-character-face "#3f444a")
  (set-face-foreground 'highlight-indent-guides-top-character-face "#875faf")
  (set-face-foreground 'highlight-indent-guides-stack-character-face "#5c5f77"))
#+end_src

*** highlight-indentation

I was using [[https://github.com/antonj/Highlight-Indentation-for-Emacs][highlight-indentation]] but it didn't look nice and the active highlighting was buggy. But it did highlight empty lines.

#+begin_src emacs-lisp
;; (use-package highlight-indentation
;;   :hook ((prog-mode . highlight-indentation-mode)
;;          (prog-mode . highlight-indentation-current-column-mode))
;;    :custom
;;    (highlight-indentation-blank-lines t) ;; Enable highlighting of blank lines.
;;    :config
;;    ;; Customize the face for the indent guides
;;    (set-face-background 'highlight-indentation-face "#3f444a")
;;    (set-face-background 'highlight-indentation-current-column-face "#5f8787"))
#+end_src
** Languages
*** TODO C++
TODO Need to set this all up better
TODO auto formatting is so bad
- new line doesnt indent at right spot
- and i dont like the auto formatting i have

#+begin_src emacs-lisp
  ;; make sure up to date
  (require 'cc-mode)

  ;; set .h files to use c++ mode instead
  (add-to-list 'auto-mode-alist '("\\.h\\'" . c++-mode))
#+end_src

*** Python
Look [[https://github.com/rememberYou/.emacs.d/blob/master/config.org#python][here]] when i need these
*** cmake
#+begin_src emacs-lisp
  (use-package cmake-mode
    :hook (cmake-mode . lsp-deferred)
    :mode ("CMakeLists\\.txt\\'" "\\.cmake\\'"))

  ;; for better sytax colours
  (use-package cmake-font-lock
    :hook (cmake-mode . cmake-font-lock-activate))
#+end_src
*** make
#+begin_src emacs-lisp
  ;; use makefile-mode for MakeFiles
  (add-to-list 'auto-mode-alist '("Makefile" . makefile-mode))
#+end_src

* TODO Writing packages
This packages are to improve all things writing.
** TODO Defaults
TODO maybe update name, and add intro summary

#+begin_src emacs-lisp
  (use-package writing
    :ensure nil
    :hook
    ;; Line Wrappings
    (text-mode . turn-on-visual-line-mode))
#+end_src
** Flyspell

Flyspell is an on-the-fly spell checker in Emacs. It works in the background while you're typing to highlight misspelled words in your buffer. Flyspell integrates with Emacs and uses a spell-checking engine like Ispell or Aspell to detect misspellings as you type.

#+begin_src emacs-lisp
  (use-package flyspell
    :ensure nil
    :delight
    :hook ((text-mode . flyspell-mode)
           (prog-mode . flyspell-prog-mode))
    :config
    (define-key flyspell-mode-map (kbd "C-;") nil) ;; unbind as used for commend-line
    :custom
    ;; Add correction to abbreviation table.
    (flyspell-abbrev-p t)
    (flyspell-default-dictionary "en_GB")
    (flyspell-issue-message-flag nil)
    (flyspell-issue-welcome-flag nil))

  ;; recommended to speed up flycheck
  ;; (setq flyspell-issue-message-flag nil)

  ;; easy spell check
  ;; (global-set-key (kbd "<f8>") 'ispell-word)
  ;; (global-set-key (kbd "C-S-<f8>") 'flyspell-mode)
  ;; (global-set-key (kbd "C-M-<f8>") 'flyspell-buffer)

  ;; (defun flyspell-check-next-highlighted-word ()
  ;;   "Custom function to spell check next highlighted word"
  ;;   (interactive)
  ;;   (flyspell-goto-next-error)
  ;;   (ispell-word)
  ;;   )
  ;; (global-set-key (kbd "C-<f8>") 'flyspell-check-next-highlighted-word)
  ;; (global-set-key (kbd "M-<f8>") 'flyspell-check-previous-highlighted-word)

#+end_src
** Ispell

Ispell is a spell-checking program that was one of the early tools for spell-checking in Unix-like systems. It's often used in Emacs and other text editors to detect and correct spelling errors. Aspell is a more modern and improved spell-checking program compared to Ispell. It has better support for multiple languages, better handling of compound words, and is more actively maintained.

#+begin_src emacs-lisp
  (use-package ispell
    ;; :custom
    ;; (ispell-hunspell-dict-paths-alist
    ;;  '(("en_US" "/usr/share/hunspell/en_US.aff")
    ;;    ("fr_BE" "/usr/share/hunspell/fr_BE.aff")))
    ;; Save words in the personal dictionary without asking.
    :custom
    (ispell-silently-savep t)
    :config
    (setenv "LANG" "en_GB")
    (cond ((executable-find "hunspell")
           (setq ispell-program-name "hunspell"))
          ((executable-find "aspell")
           (setq ispell-program-name "aspell")
           (setq ispell-extra-args '("--sug-mode=ultra"))))
    ;; Ignore file sections for spell checking.
    (add-to-list 'ispell-skip-region-alist '("#\\+begin_align" . "#\\+end_align"))
    (add-to-list 'ispell-skip-region-alist '("#\\+begin_align*" . "#\\+end_align*"))
    (add-to-list 'ispell-skip-region-alist '("#\\+begin_equation" . "#\\+end_equation"))
    (add-to-list 'ispell-skip-region-alist '("#\\+begin_equation*" . "#\\+end_equation*"))
    (add-to-list 'ispell-skip-region-alist '("#\\+begin_example" . "#\\+end_example"))
    (add-to-list 'ispell-skip-region-alist '("#\\+begin_labeling" . "#\\+end_labeling"))
    (add-to-list 'ispell-skip-region-alist '("#\\+begin_src" . "#\\+end_src"))
    (add-to-list 'ispell-skip-region-alist '("\\$" . "\\$"))
    (add-to-list 'ispell-skip-region-alist '(org-property-drawer-re))
    (add-to-list 'ispell-skip-region-alist '(":\\(PROPERTIES\\|LOGBOOK\\):" . ":END:")))
#+end_src

** LanguageTools
[[https://languagetool.org/][LanguageTool]] is great for correcting your grammar while you are writing or saving your buffer. To use LanguageTool with LSP mode, the [[https://github.com/emacs-languagetool/lsp-ltex][lsp-ltex]] package is what you need. The first time you use it, it will download the [[https://github.com/valentjn/ltex-ls][LTEX Language Server]] LSP server for you.

*NOTE:* I don't hook =lsp-ltex= to =text-mode= since it would process the =config.org= file which has too many errors to be processed properly.

#+begin_src emacs-lisp
  (use-package lsp-ltex
    :after lsp-mode
    :hook ((latex-mode) . (lambda ()
                            (require 'lsp-ltex)
                            (lsp)))
    :init
    (setq lsp-ltex-version "16.0.0"))
#+end_src

** writegood-mode
#+begin_src emacs-lisp
  (use-package writegood-mode
    :ensure t)

  (add-hook 'TeX-mode-hook 'writegood-mode)
#+end_src

** TODO LaTeX

TODO - need to add a better language server, and in general look over these packages and see what i want/ if there are alternatives.

I use the =tex-mode= built-in package and [[https://github.com/latex-lsp/texlab][texlab]] as LSP server. To use it, make sure you install it with your package manager and to configure the LSP package.

With =tex-mode= we need to ensure to install AUCTeX, which is a built-in package for writing and formatting TeX files in GNU Emacs. With =AUCTeX= you can for example use the =TeX-command-master= (=C-c C-c=) command to compile your TeX files
and the =LaTeX-environment= (=C-c C-e=) command to insert a LaTeX environment.

#+begin_src emacs-lisp
  (use-package tex
    :ensure auctex
    :hook
    (TeX-mode . display-line-numbers-mode)
    :preface
    (defun my/switch-to-help-window (&optional ARG REPARSE)
      "Switches to the *TeX Help* buffer after compilation."
      (other-window 1))
    :hook ((LaTeX-mode . reftex-mode)
           (LaTeX-mode . prettify-symbols-mode))
    :bind (:map TeX-mode-map
                ("C-c C-o" . TeX-recenter-output-buffer)
                ("C-c C-l" . TeX-next-error)
                ("M-[" . outline-previous-heading)
                ("M-]" . outline-next-heading))
    :custom
    (TeX-auto-save t)
    (TeX-byte-compile t)
    (TeX-clean-confirm nil)
    (TeX-master 'dwim)
    (TeX-parse-self t)
    (TeX-PDF-mode t)
    (TeX-source-correlate-mode t)
    (TeX-view-program-selection '((output-pdf "PDF Tools")))
    :config
    (advice-add 'TeX-next-error :after #'my/switch-to-help-window)
    (advice-add 'TeX-recenter-output-buffer :after #'my/switch-to-help-window)
    ;; the ":hook" doesn't work for this one... don't ask me why.
    (add-hook 'TeX-after-compilation-finished-functions 'TeX-revert-document-buffer))
#+end_src

Also, I like to use a TeX engine that can handle Unicode and use the font of my choice.

#+begin_src emacs-lisp
  (setq-default TeX-engine 'xetex)
#+end_src

By default, LSP mode uses =lsp-tex= as the LSP client for LaTeX. However, I prefer to use [[https://github.com/ROCKTAKEY/lsp-latex][lsp-latex]] which fully supports =texlab= (cf. https://github.com/ROCKTAKEY/lsp-latex/issues/26)

#+begin_src emacs-lisp
  (use-package lsp-latex
    :if (executable-find "texlab")
    ;; To properly load `lsp-latex', the `require' instruction is important.
    :hook (LaTeX-mode . (lambda ()
                          (require 'lsp-latex)
                          (lsp-deferred)))
    :custom (lsp-latex-build-on-save t))
#+end_src

To easier deal with =\label=, =\ref=, and =\cite= commands in LaTeX, I use the =reftex= built-in package.

#+begin_src emacs-lisp
  (use-package reftex
    :ensure nil
    :custom
    (reftex-save-parse-info t)
    (reftex-use-multiple-selection-buffers t))
#+end_src

Finally, it is often useful to put our hands in a bibliography in LaTeX. The built-in package =bibtex= improves the visual and provides several commands.

#+begin_src emacs-lisp
  (use-package bibtex
    :ensure nil
    :preface
    (defun my/bibtex-fill-column ()
      "Ensure that each entry does not exceed 120 characters."
      (setq fill-column 120))
    :hook ((bibtex-mode . lsp-deferred)
           (bibtex-mode . my/bibtex-fill-column)))
#+end_src
* TODO Org-mode
TODO needs a big tidy up (could be its own heading?, see https://github.com/rememberYou/.emacs.d/blob/master/config.org#org-mode

A lot of these changes are based of [[https://doc.norang.ca/org-mode.html#HowToUseThisDocument][this]].

** TODO My defaults
TODO add these to a use-package

#+begin_src emacs-lisp
  ;; indent with tabs for better readability
  (add-hook 'org-mode-hook #'org-indent-mode)
  ;; (setq org-indent-indentation-per-level 4)

  ;; When editing org-files with source-blocks, we want the source blocks to be themed as they would in their native mode.
  (setq org-src-fontify-natively t
    org-src-tab-acts-natively t
    org-confirm-babel-evaluate nil)
#+end_src

#+begin_src emacs-lisp
  ;; Standard key bindings
  ;; (global-set-key (kbd "\C-c l") 'org-store-link)
  (global-set-key (kbd "\C-c a") 'org-agenda)
  (global-set-key (kbd "\C-c c") 'org-capture)
  (global-set-key (kbd "\C-c b") 'org-iswitchb)
#+end_src

** TODO Agenda
Lots to do here

#+begin_src emacs-lisp
  ;; Get all my agenda files
  (setq org-agenda-files
        (mapcar 'abbreviate-file-name
                (split-string
                 (shell-command-to-string "find ~/Documents/agenda -name \"*.org\"")
                 "\n")))

  ;; Define the keywords for the agenda
  (setq org-todo-keywords
        '((sequence "TODO(t)"    "NEXT(n)" "|" "DONE(d)")
          (sequence "WAITING(w)" "HOLD(h)" "|" "CANCELLED(c)")))

  (setq org-log-done 'time)

  ;; Set default column view headings: Task Total-Time Time-Stamp
  (setq org-columns-default-format "%50ITEM(Task) %TIMESTAMP_IA")

  ;; Colour the keywords
  (setq org-todo-keyword-faces
        (quote (("TODO"      :foreground "red"          :weight bold)
                ("NEXT"      :foreground "blue"         :weight bold)
                ("DONE"      :foreground "forest green" :weight bold)
                ("WAITING"   :foreground "orange"       :weight bold)
                ("HOLD"      :foreground "magenta"      :weight bold)
                ("CANCELLED" :foreground "forest green" :weight bold))))
#+end_src

** TODO Roam
TODO write intro
TODO learn to use
TODO learn to use dailies (when i make one its putting everything before the properties.

#+begin_src emacs-lisp
  (use-package org-roam
    :custom
    (org-roam-directory "~/Documents/RoamNodes")
    (org-roam-dailies-directory "dailies/")
    (org-roam-completion-everywhere t)
    :bind (("C-c n l" . org-roam-buffer-toggle)
           ("C-c n f" . org-roam-node-find)
           ("C-c n i" . org-roam-node-insert)
           :map org-mode-map
           ("C-M-i" . completion-at-point)
           :map org-roam-dailies-map
           ("Y" . org-roam-dailies-capture-yesterday)
           ("T" . org-roam-dailies-capture-tomorrow))
    :bind-keymap
    ("C-c n d" . org-roam-dailies-map)
    :config
    (org-roam-setup)
    (require 'org-roam-dailies) ;; Ensure the keymap is available
    (org-roam-db-autosync-mode))
#+end_src

*** TODO org-bullets
TODO write intro

#+begin_src emacs-lisp
  ;; Org bullets makes things look pretty
  (use-package org-bullets
    :hook
    (org-mode . (lambda ()
                  (org-bullets-mode 1))))
  #+end_src
*** toc-org
In order to auto generate the table of contents of this file (and others) I'm using the [[https://github.com/snosov1/toc-org][toc-org]] package. Every time you save an org file, the first headline with a =:TOC:= tag will be updated with the current table of contents (=:TOC_2:= sets the max depth to 2).

#+begin_src emacs-lisp
  (use-package toc-org
    :hook (org-mode . toc-org-enable))
#+end_src
** TODO Packages
* TODO Hydra
could maybe be its own head? - maybe move back cause i lit never use it so kinda dont think i should spend ages on it
could put this is one of like (my own packages or my own lisp)
also think maybe it makes more sense for these to be with their packages - therefore move this to the start

** Git sync
This hydra command lets me quickly sync repos to the correct server

#+begin_src emacs-lisp
  ;; Define a hydra to choose the target server (nersc or deucalion)
  (defhydra hydra-sync-git (:color blue)
    "
  Sync to which server?
  _n_ NERSC
  _d_ Deucalion
  _q_ Quit
  "
    ("n" (run-sync-git-tracked-script "nersc"))
    ("d" (run-sync-git-tracked-script "deucalion"))
    ("q" nil "quit"))

  ;; Function to run the sync script with an argument
  (defun run-sync-git-tracked-script (target)
    "Run the sync_git_tracked.sh script with the specified TARGET argument."
    (interactive "sTarget (nersc or deucalion): ") ;; Allow the hydra to pass this value
    (let ((default-directory (locate-dominating-file default-directory ".git")))
      (if default-directory
          (progn
            ;; Run the sync script with the argument based on the hydra choice
            (let ((script (concat "~/git/scripts/sync_git_tracked.sh")))
              (if (file-executable-p script)
                  (call-process-shell-command (concat script " " target) nil "*scratch*")
                (message "Error: sync_git_tracked.sh not found or not executable."))))
        (message "Error: Not inside a Git repository!"))))

  ;; Bind the hydra to a keyboard shortcut
  (global-set-key (kbd "C-c s") 'hydra-sync-git/body)
#+end_src
